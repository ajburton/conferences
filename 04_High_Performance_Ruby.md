# High Performance Ruby
## Charles Nutter

## Introduction

JRuby
How do we make Ruby fast?

## What does performance mean?
Man hours vs. CPU
Straightline, time

## High Performance?
which ruby implementation
ruby faster than other runtimes?

## Fast Enough?
1.9.3 fast enough and 1.8.7 is slow

## Performance Wall
Can't get done what you want to get done
You're bound by your architecture
Move to different runtime

*If you're not writing performance sensitive code in Ruby, you're giving
up too easily!!!*

## Native Extensions
Not universally bad, but bad in MRI
What is bad is the way their implemented within CRuby
Unless you're in MRI, you're limited when writing native extensions

## What We Want
Faster execution
Better GC, non-blocking
Parallel Execution via threads or actors within a process
Big data by continuous scans

*Can't have any of these with current C extension implementations!*

## Different Approach
Don't fallback to C, so lets improve Ruby to make it faster.

1. Build your own runtime like YARV, Rubinius or MacRuby
2. Use an existing runtime like JRuby

## Build or Buy
Making a new VM is easy (early rubinuius was simple)
Making a new VM competitive is *really really hard*

## JRuby choose JVM
15 years of open source experience and super quick
Best GCs available
Rull parallel threading
Broad platform support so wide adoption

## But Java Is Slow?

Rumor is dying because Java is now C fast
Java is terrible for application development because too many abstractions
Simple algorithms can compile to same bytecode as C
*The way you write code is much more important than what you write it in*

## JRuby
Java implementation of Ruby on JVM
1 to 1 compatible with MRI
JRuby JITs to JVM bytecode

## Can Still Be Faster
Still things about Ruby which defy optimization such as interpreter optimization

(see slides for great timeline of commits)

## Goal is to Align Ruby with JVM
Ruby local variables are JVM local variables
Avoid inter-call goo
*Eliminate unnecessary work*

## Unnecessary Work
Everything is a map such as modules, instance variables

## Method Lookup
Method lookups go up-hierarchy
Lookup target caches result (child caches method defined in parent)
Modification cascades down

## Bottom Line of Optimizing Ruby
Make calls fast
Make constants free

## Invokedynamics

## JVM 101
Opcodes / Data endpoints
 * Invocation
 * Field access getting data out of object
 * Array access
All Java code revolves around these endpoints

If you every stray outside of opcodes, you are stuck!
We need millions of operations!
With invokedynamic, we can get around this problem
  1. invokedynamic bytecode
  2. bootstrap method
  3. method handles
  4. find target method on JVM
  (see diagram on slides)
Now the path is cached and optimized!

*InvokeDynamic lets JRuby teach the JVM how Ruby works, so the JVM can
optimize like any other language on the JVM*

## How do we know JRuby is fast?

*Benchmarking is really hard*

## JVM opto 101
JITs code bodies after 10k calls
Inlines up to two targets
Optimistics by making very aggressive decisions
  Makes optimistics decisions for a small system, but those decisions
  will have to be reversed for large systems
Inlining optimizes and writes bytecode for a chunk of code instead of pieces

Benchmarking is not always enough, you have to read the assembly generated by JVM

## Moral
Benchmarks are synthetic
Every system is different
Figure out what is slow in your system, and benchmark this part of your system

## Rails?
Significant gains for some folks

## What is next?
Expand where JRuby optimizes such as super

## Whacky stuff?
Optimize things like `respond_to?` or `method_missing`

## The Future
JRuby will get faster!
InvokeDynamic will get faster!

_Look up Ruby flip-flops_







